Алгоритм блочной сортировки (Bucket Sort)

Суть метода: Блочная сортировка работает по принципу распределения элементов по различным контейнерам в соответствии с их значением. После распределения каждый контейнер сортируется независимо, затем результаты объединяются.

Механизм работы

Определение границ значений:

python
max_val = max(array)
min_val = min(array)
Эти вычисления необходимы для определения размеров интервалов каждого контейнера.

Инициализация контейнеров:

python
buckets = [[] for _ in range(num_buckets)]
Распределение по контейнерам:

python
bucket_index = int((element - min_val) // bucket_range)
Каждый элемент направляется в соответствующий контейнер на основе его положения в общем диапазоне.

Сортировка контейнеров:

python
result.extend(sort_bucket(bucket))
Для сортировки отдельных контейнеров применяется подходящий алгоритм.

Формирование результата:
Отсортированные контейнеры последовательно объединяются.

Анализ производительности

Распределение элементов: O(n)
Сортировка контейнеров: В среднем O(m log m) на контейнер
Худший случай: O(n²) при концентрации всех элементов в одном контейнере

Алгоритм блинной сортировки (Pancake Sort)

Особенность метода: Этот алгоритм использует операцию переворота segments массива, имитируя переворачивание стопки блинов.

Процесс выполнения

Функция переворота:

python
def flip_array(arr, k):
Переворачивает первые k элементов массива.

Основная логика:

Находим позицию максимального элемента в неотсортированной части
Если максимум не на своем месте, выполняем два переворота
Сначала поднимаем максимум наверх, затем опускаем на нужную позицию
Ключевые операции:

python
max_pos = arr.index(max(arr[:current_size]))
flip_array(arr, max_pos + 1)
flip_array(arr, current_size)
Производительность

Сложность: O(n²)
Причины:

Поиск максимума: O(n) на каждой итерации
Количество итераций: n-1
Операции переворота: O(n) каждая
Алгоритм гравитационной сортировки (Bead Sort)

Концепция: Моделирует процесс падения бусин под действием гравиации, где каждая бусина представляет единицу значения.

Реализация

Определение параметров:

python
max_val = max(input_array)
Создание рабочей матрицы:

python
bead_matrix = [[False]*len(input_array) for _ in range(max_val)]
Процесс сортировки:

Заполнение матрицы бусинами согласно исходным значениям
Имитация падения бусин (сдвиг вниз)
Подсчет бусин в каждом столбце для получения отсортированного массива
Эффективность

Сложность: O(n × k), где k - максимальное значение
Ограничения: Практическое применение ограничено массивами с небольшими значениями

Алгоритм поиска прыжками (Jump Search)

Стратегия: Комбинированный подход для отсортированных массивов, сочетающий крупные шаги с последующим линейным поиском.

Реализация

Определение шага:

python
step_size = int(math.sqrt(len(arr)))
Процесс поиска:

Прыжки с фиксированным шагом для быстрого определения потенциального блока
Детальный линейный поиск внутри найденного блока
Производительность

Сложность: O(√n)
Оптимальность: Шаг √n обеспечивает баланс между количеством прыжков и размером области линейного поиска

Алгоритм экспоненциального поиска (Exponential Search)

Подход: Быстрое определение границ поиска с последующим применением бинарного поиска.

Механизм работы

Определение диапазона:

python
bound = 1
while bound < n and arr[bound] < target:
    bound *= 2
Уточнение позиции:

python
return binary_search(arr, bound//2, min(bound, n-1), target)
Эффективность

Сложность: O(log n)
Преимущества: Особенно эффективен для неограниченных массивов и поиска near the beginning
