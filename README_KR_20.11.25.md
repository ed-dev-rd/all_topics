Задание 12. Локальный поиск: оптимизация расписания
-
Условие. Есть n задач с длительностями и m машин. Распределить задачи так, чтобы
минимизировать максимальное время загрузки машины (makespan).
Алгоритм: локальный поиск с перекладыванием одной задачи на другую машину.
Язык примера: Java
public static int[] localSearchSchedule(int[] durations, int m, int maxIter) {
int n = durations.length;
int[] assignment = new int[n]; // машина для каждой задачи
int[] load = new int[m];
// Инициализация случайного распределения
for (int i = 0; i < n; i++) {
assignment[i] = (int) (Math.random() * m);
load[assignment[i]] += durations[i];
}
for (int iter = 0; iter < maxIter; iter++) {
// ДОПИСАТЬ: выбрать случайную задачу и попробовать переложить на другую
машину
// если makespan улучшается — принять изменение
}
return assignment;
}
Что дописать: цикл перебора задач и машин, расчёт нового makespan.

Алгоритм кода:
-

**1) Инициализация случайного распределения задач по машинам**

for (int i = 0; i < n; i++) {
    assignment[i] = (int) (Math.random() * m);
    load[assignment[i]] += durations[i];
}

Создаем начальное решение, случайно назначая задачи машинам
Одновременно вычисляем загрузку каждой машины

**2) Основной цикл локального поиска (maxIter итераций)**

for (int iter = 0; iter < maxIter; iter++) {

Выполняем заданное количество итераций улучшения
Каждая итерация пытается улучшить текущее решение

**3) Вычисление текущего makespan (максимальной загрузки)**

int currentMaxLoad = 0;
for (int j = 0; j < m; j++) {
    if (load[j] > currentMaxLoad) {
        currentMaxLoad = load[j];
    }
}

Находим машину с максимальной загрузкой
Это текущее значение целевой функции (makespan)

**4) Выбор случайной задачи для потенциального перемещения**

int taskIdx = (int) (Math.random() * n);
int currentMachine = assignment[taskIdx];
int taskDuration = durations[taskIdx];

Случайно выбираем задачу, которую будем пытаться переместить
Запоминаем её текущую машину и длительность

**5) Перебор всех возможных целевых машин для перемещения**

for (int newMachine = 0; newMachine < m; newMachine++) {
    if (newMachine == currentMachine) continue;
    
Пробуем переместить задачу на каждую другую машину
Пропускаем текущую машину (бессмысленное действие)

**6) Расчет новой загрузки после перемещения**

int newLoadCurrent = load[currentMachine] - taskDuration;
int newLoadNew = load[newMachine] + taskDuration;э

Вычисляем новую загрузку исходной машины (уменьшается)
Вычисляем новую загрузку целевой машины (увеличивается)

**7) Вычисление нового makespan после перемещения**

int newMaxLoad = Math.max(newLoadNew, newLoadCurrent);
for (int j = 0; j < m; j++) {
    if (j != currentMachine && j != newMachine) {
        if (load[j] > newMaxLoad) {
            newMaxLoad = load[j];
        }
    }
}

Новый makespan - максимум из загрузок всех машин
Учитываем, что загрузки других машин не изменились

**8) Проверка улучшения и принятие изменения**

if (newMaxLoad < currentMaxLoad) {
    assignment[taskIdx] = newMachine;
    load[currentMachine] = newLoadCurrent;
    load[newMachine] = newLoadNew;
    break;
}

Если перемещение улучшает makespan, принимаем его
Обновляем назначение задачи и загрузки машин
Прерываем перебор машин для этой задачи

**9) Возврат финального распределения**

return assignment;
После всех итераций возвращаем лучшее найденное распределение

Временная сложность: 
-
O(maxIter × n × m)

**Обоснование временной сложности:**

Алгоритм состоит из двух основных этапов:

1) Инициализация случайного распределения:

for (int i = 0; i < n; i++) {
    assignment[i] = (int) (Math.random() * m);
    load[assignment[i]] += durations[i];
}

Сложность: O(n)

Выполняется n операций присваивания и обновления загрузки

2) Основной цикл локального поиска:

for (int iter = 0; iter < maxIter; iter++) {
    // Вычисление текущего makespan: O(m)
    // Выбор случайной задачи: O(1)  
    // Цикл по всем машинам: O(m)
    for (int newMachine = 0; newMachine < m; newMachine++) {
        // Вычисление нового makespan: O(m)
    }
}

Внешний цикл выполняется maxIter раз

В каждой итерации:

Вычисление текущего makespan: O(m)

Цикл по m машинам: O(m) итераций

Внутри цикла по машинам вычисление нового makespan: O(m)

Общая сложность:

Сложность определяется как O(n) + O(maxIter × (m + m × m))

Поскольку при больших значениях maxIter, n и m операция O(maxIter × m²) доминирует над O(n), общая сложность алгоритма составляет O(maxIter × n × m).

12.Критерий Метрополиса
Какова формула критерия Метрополиса в алгоритме имитации отжига и что она означает?
-

**Формула критерия Метрополиса:**

P = exp(-ΔE / T), где

P — вероятность принятия ухудшающего решения

ΔE — изменение целевой функции (разница между новым и текущим решением)

T — текущая "температура" в алгоритме

exp — экспоненциальная функция

**Смысл и применение критерия:**

Критерий Метрополиса является фундаментальным компонентом алгоритма имитации отжига, который определяет, следует ли принимать решения, ухудшающие текущее состояние. В отличие от жадных алгоритмов, которые принимают только улучшающие изменения, имитация отжига использует вероятностный подход для выхода из локальных оптимумов.

**Детальное объяснение компонентов формулы:**

ΔE (изменение энергии):

В физической аналогии ΔE представляет изменение энергии системы

В оптимизационных задачах ΔE = f(new) - f(current), где f — целевая функция

При минимизации: ΔE > 0 означает ухудшение решения

При максимизации: ΔE < 0 означает ухудшение решения

T (температура):

Параметр, контролирующий вероятность принятия плохих решений
В начале алгоритма T высокая, что позволяет активно исследовать пространство решений
По мере работы алгоритма T уменьшается по schedule охлаждения
При T → 0 алгоритм превращается в жадный поиск

**Экспоненциальная функция exp():**

Обеспечивает плавное уменьшение вероятности с ростом ΔE
Гарантирует, что небольшие ухудшения принимаются с большей вероятностью
Значительные ухудшения имеют очень низкую вероятность принятия
Практическая реализация критерия:

В алгоритме для каждого кандидатного решения вычисляется ΔE. Если ΔE ≤ 0 (улучшение), решение всегда принимается. Если ΔE > 0 (ухудшение), генерируется случайное число r ∈ [0,1] и решение принимается, если:

r < exp(-ΔE / T)

**Эволюция вероятности во времени:**

Высокая температура: При больших T значение exp(-ΔE/T) ≈ 1, поэтому почти все ухудшения принимаются
Средняя температура: Вероятность принимает значения от 0 до 1 в зависимости от величины ухудшения
Низкая температура: exp(-ΔE/T) ≈ 0, поэтому принимаются только улучшения или очень небольшие ухудшения

**Значение в контексте оптимизации:**

Критерий Метрополиса позволяет алгоритму:

Исследовать пространство решений на ранних стадиях
Выходить из локальных оптимумов за счет временного ухудшения качества
Стабилизироваться вблизи глобального оптимума на поздних стадиях
Балансировать между исследованием и эксплуатацией
Связь с физическим процессом:

В оригинальной физической интерпретации критерий описывает вероятность перехода физической системы в состояние с более высокой энергией при термических флуктуациях. В оптимизации этот принцип позволяет "встряхивать" текущее решение, чтобы преодолевать энергетические барьеры между локальными оптимумами.

Таким образом, критерий Метрополиса является ключевым механизмом, который отличает имитацию отжига от других методов локального поиска и позволяет эффективно решать сложные оптимизационные задачи с множеством локальных оптимумов.













